"use strict";
// Copyright 2023 Lance Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricType = exports.isWriteOptions = exports.DefaultWriteOptions = exports.WriteMode = exports.LocalTable = exports.LocalConnection = exports.connect = exports.OpenAIEmbeddingFunction = exports.Query = void 0;
const apache_arrow_1 = require("apache-arrow");
const arrow_1 = require("./arrow");
const remote_1 = require("./remote");
const query_1 = require("./query");
Object.defineProperty(exports, "Query", { enumerable: true, get: function () { return query_1.Query; } });
const embedding_function_1 = require("./embedding/embedding_function");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { databaseNew, databaseTableNames, databaseOpenTable, databaseDropTable, tableCreate, tableAdd, tableCreateVectorIndex, tableCountRows, tableDelete } = require('../native.js');
var openai_1 = require("./embedding/openai");
Object.defineProperty(exports, "OpenAIEmbeddingFunction", { enumerable: true, get: function () { return openai_1.OpenAIEmbeddingFunction; } });
function connect(arg) {
    return __awaiter(this, void 0, void 0, function* () {
        let opts;
        if (typeof arg === 'string') {
            opts = { uri: arg };
        }
        else {
            // opts = { uri: arg.uri, awsCredentials = arg.awsCredentials }
            opts = Object.assign({
                uri: '',
                awsCredentials: undefined,
                apiKey: undefined,
                region: 'us-west-2'
            }, arg);
        }
        if (opts.uri.startsWith('db://')) {
            // Remote connection
            return new remote_1.RemoteConnection(opts);
        }
        const db = yield databaseNew(opts.uri);
        return new LocalConnection(db, opts);
    });
}
exports.connect = connect;
/**
 * A connection to a LanceDB database.
 */
class LocalConnection {
    constructor(db, options) {
        this._options = options;
        this._db = db;
    }
    get uri() {
        return this._options.uri;
    }
    /**
     * Get the names of all tables in the database.
     */
    tableNames() {
        return __awaiter(this, void 0, void 0, function* () {
            return databaseTableNames.call(this._db);
        });
    }
    openTable(name, embeddings) {
        return __awaiter(this, void 0, void 0, function* () {
            const tbl = yield databaseOpenTable.call(this._db, name);
            if (embeddings !== undefined) {
                return new LocalTable(tbl, name, this._options, embeddings);
            }
            else {
                return new LocalTable(tbl, name, this._options);
            }
        });
    }
    createTable(name, data, optsOrEmbedding, opt) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let writeOptions = new DefaultWriteOptions();
            if (opt !== undefined && isWriteOptions(opt)) {
                writeOptions = opt;
            }
            else if (optsOrEmbedding !== undefined && isWriteOptions(optsOrEmbedding)) {
                writeOptions = optsOrEmbedding;
            }
            let embeddings;
            if (optsOrEmbedding !== undefined && (0, embedding_function_1.isEmbeddingFunction)(optsOrEmbedding)) {
                embeddings = optsOrEmbedding;
            }
            const createArgs = [this._db, name, yield (0, arrow_1.fromRecordsToBuffer)(data, embeddings), (_a = writeOptions.writeMode) === null || _a === void 0 ? void 0 : _a.toString()];
            if (this._options.awsCredentials !== undefined) {
                createArgs.push(this._options.awsCredentials.accessKeyId);
                createArgs.push(this._options.awsCredentials.secretKey);
                if (this._options.awsCredentials.sessionToken !== undefined) {
                    createArgs.push(this._options.awsCredentials.sessionToken);
                }
            }
            const tbl = yield tableCreate.call(...createArgs);
            if (embeddings !== undefined) {
                return new LocalTable(tbl, name, this._options, embeddings);
            }
            else {
                return new LocalTable(tbl, name, this._options);
            }
        });
    }
    createTableArrow(name, table) {
        return __awaiter(this, void 0, void 0, function* () {
            const writer = apache_arrow_1.RecordBatchFileWriter.writeAll(table);
            yield tableCreate.call(this._db, name, Buffer.from(yield writer.toUint8Array()));
            return yield this.openTable(name);
        });
    }
    /**
     * Drop an existing table.
     * @param name The name of the table to drop.
     */
    dropTable(name) {
        return __awaiter(this, void 0, void 0, function* () {
            yield databaseDropTable.call(this._db, name);
        });
    }
}
exports.LocalConnection = LocalConnection;
class LocalTable {
    constructor(tbl, name, options, embeddings) {
        this._tbl = tbl;
        this._name = name;
        this._embeddings = embeddings;
        this._options = options;
    }
    get name() {
        return this._name;
    }
    /**
     * Creates a search query to find the nearest neighbors of the given search term
     * @param query The query search term
     */
    search(query) {
        return new query_1.Query(query, this._tbl, this._embeddings);
    }
    /**
     * Insert records into this Table.
     *
     * @param data Records to be inserted into the Table
     * @return The number of rows added to the table
     */
    add(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const callArgs = [this._tbl, yield (0, arrow_1.fromRecordsToBuffer)(data, this._embeddings), WriteMode.Append.toString()];
            if (this._options.awsCredentials !== undefined) {
                callArgs.push(this._options.awsCredentials.accessKeyId);
                callArgs.push(this._options.awsCredentials.secretKey);
                if (this._options.awsCredentials.sessionToken !== undefined) {
                    callArgs.push(this._options.awsCredentials.sessionToken);
                }
            }
            return tableAdd.call(...callArgs);
        });
    }
    /**
     * Insert records into this Table, replacing its contents.
     *
     * @param data Records to be inserted into the Table
     * @return The number of rows added to the table
     */
    overwrite(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const callArgs = [this._tbl, yield (0, arrow_1.fromRecordsToBuffer)(data, this._embeddings), WriteMode.Overwrite.toString()];
            if (this._options.awsCredentials !== undefined) {
                callArgs.push(this._options.awsCredentials.accessKeyId);
                callArgs.push(this._options.awsCredentials.secretKey);
                if (this._options.awsCredentials.sessionToken !== undefined) {
                    callArgs.push(this._options.awsCredentials.sessionToken);
                }
            }
            return tableAdd.call(this._tbl, yield (0, arrow_1.fromRecordsToBuffer)(data, this._embeddings), WriteMode.Overwrite.toString());
        });
    }
    /**
     * Create an ANN index on this Table vector index.
     *
     * @param indexParams The parameters of this Index, @see VectorIndexParams.
     */
    createIndex(indexParams) {
        return __awaiter(this, void 0, void 0, function* () {
            return tableCreateVectorIndex.call(this._tbl, indexParams);
        });
    }
    /**
     * Returns the number of rows in this table.
     */
    countRows() {
        return __awaiter(this, void 0, void 0, function* () {
            return tableCountRows.call(this._tbl);
        });
    }
    /**
     * Delete rows from this table.
     *
     * @param filter A filter in the same format used by a sql WHERE clause.
     */
    delete(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            return tableDelete.call(this._tbl, filter);
        });
    }
}
exports.LocalTable = LocalTable;
/**
 * Write mode for writing a table.
 */
var WriteMode;
(function (WriteMode) {
    /** Create a new {@link Table}. */
    WriteMode["Create"] = "create";
    /** Overwrite the existing {@link Table} if presented. */
    WriteMode["Overwrite"] = "overwrite";
    /** Append new data to the table. */
    WriteMode["Append"] = "append";
})(WriteMode = exports.WriteMode || (exports.WriteMode = {}));
class DefaultWriteOptions {
    constructor() {
        this.writeMode = WriteMode.Create;
    }
}
exports.DefaultWriteOptions = DefaultWriteOptions;
function isWriteOptions(value) {
    return Object.keys(value).length === 1 &&
        (value.writeMode === undefined || typeof value.writeMode === 'string');
}
exports.isWriteOptions = isWriteOptions;
/**
 * Distance metrics type.
 */
var MetricType;
(function (MetricType) {
    /**
     * Euclidean distance
     */
    MetricType["L2"] = "l2";
    /**
     * Cosine distance
     */
    MetricType["Cosine"] = "cosine";
    /**
     * Dot product
     */
    MetricType["Dot"] = "dot";
})(MetricType = exports.MetricType || (exports.MetricType = {}));
