"use strict";
// Copyright 2023 Lance Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromRecordsToBuffer = exports.convertToTable = void 0;
const apache_arrow_1 = require("apache-arrow");
function convertToTable(data, embeddings) {
    return __awaiter(this, void 0, void 0, function* () {
        if (data.length === 0) {
            throw new Error('At least one record needs to be provided');
        }
        const columns = Object.keys(data[0]);
        const records = {};
        for (const columnsKey of columns) {
            if (columnsKey === 'vector') {
                const listBuilder = newVectorListBuilder();
                const vectorSize = data[0].vector.length;
                for (const datum of data) {
                    if (datum[columnsKey].length !== vectorSize) {
                        throw new Error(`Invalid vector size, expected ${vectorSize}`);
                    }
                    listBuilder.append(datum[columnsKey]);
                }
                records[columnsKey] = listBuilder.finish().toVector();
            }
            else {
                const values = [];
                for (const datum of data) {
                    values.push(datum[columnsKey]);
                }
                if (columnsKey === (embeddings === null || embeddings === void 0 ? void 0 : embeddings.sourceColumn)) {
                    const vectors = yield embeddings.embed(values);
                    const listBuilder = newVectorListBuilder();
                    vectors.map(v => listBuilder.append(v));
                    records.vector = listBuilder.finish().toVector();
                }
                if (typeof values[0] === 'string') {
                    // `vectorFromArray` converts strings into dictionary vectors, forcing it back to a string column
                    records[columnsKey] = (0, apache_arrow_1.vectorFromArray)(values, new apache_arrow_1.Utf8());
                }
                else {
                    records[columnsKey] = (0, apache_arrow_1.vectorFromArray)(values);
                }
            }
        }
        return new apache_arrow_1.Table(records);
    });
}
exports.convertToTable = convertToTable;
// Creates a new Arrow ListBuilder that stores a Vector column
function newVectorListBuilder() {
    const children = new apache_arrow_1.Field('item', new apache_arrow_1.Float32());
    const list = new apache_arrow_1.List(children);
    return (0, apache_arrow_1.makeBuilder)({
        type: list
    });
}
function fromRecordsToBuffer(data, embeddings) {
    return __awaiter(this, void 0, void 0, function* () {
        const table = yield convertToTable(data, embeddings);
        const writer = apache_arrow_1.RecordBatchFileWriter.writeAll(table);
        return Buffer.from(yield writer.toUint8Array());
    });
}
exports.fromRecordsToBuffer = fromRecordsToBuffer;
