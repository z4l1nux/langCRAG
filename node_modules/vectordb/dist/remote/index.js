"use strict";
// Copyright 2023 LanceDB Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteTable = exports.RemoteQuery = exports.RemoteConnection = void 0;
const query_1 = require("../query");
const apache_arrow_1 = require("apache-arrow");
const client_1 = require("./client");
/**
 * Remote connection.
 */
class RemoteConnection {
    constructor(opts) {
        if (!opts.uri.startsWith('db://')) {
            throw new Error(`Invalid remote DB URI: ${opts.uri}`);
        }
        if (opts.apiKey === undefined || opts.region === undefined) {
            throw new Error('API key and region are not supported for remote connections');
        }
        this._dbName = opts.uri.slice('db://'.length);
        let server;
        if (opts.hostOverride === undefined) {
            server = `https://${this._dbName}.${opts.region}.api.lancedb.com`;
        }
        else {
            server = opts.hostOverride;
        }
        this._client = new client_1.HttpLancedbClient(server, opts.apiKey, opts.hostOverride === undefined ? undefined : this._dbName);
    }
    get uri() {
        // add the lancedb+ prefix back
        return 'db://' + this._client.uri;
    }
    tableNames() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._client.get('/v1/table/');
            return response.data.tables;
        });
    }
    openTable(name, embeddings) {
        return __awaiter(this, void 0, void 0, function* () {
            if (embeddings !== undefined) {
                return new RemoteTable(this._client, name, embeddings);
            }
            else {
                return new RemoteTable(this._client, name);
            }
        });
    }
    createTable(name, data, embeddings) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
    createTableArrow(name, table) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
    dropTable(name) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
}
exports.RemoteConnection = RemoteConnection;
class RemoteQuery extends query_1.Query {
    constructor(query, _client, _name, embeddings) {
        super(query, undefined, embeddings);
        this._client = _client;
        this._name = _name;
    }
    // TODO: refactor this to a base class + queryImpl pattern
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            const embeddings = this._embeddings;
            const query = this._query;
            let queryVector;
            if (embeddings !== undefined) {
                queryVector = (yield embeddings.embed([query]))[0];
            }
            else {
                queryVector = query;
            }
            const data = yield this._client.search(this._name, queryVector, this._limit, this._nprobes, this._refineFactor, this._select, this._filter);
            return data.toArray().map((entry) => {
                const newObject = {};
                Object.keys(entry).forEach((key) => {
                    if (entry[key] instanceof apache_arrow_1.Vector) {
                        newObject[key] = entry[key].toArray();
                    }
                    else {
                        newObject[key] = entry[key];
                    }
                });
                return newObject;
            });
        });
    }
}
exports.RemoteQuery = RemoteQuery;
// we are using extend until we have next next version release
// Table and Connection has both been refactored to interfaces
class RemoteTable {
    constructor(client, name, embeddings) {
        this._client = client;
        this._name = name;
        this._embeddings = embeddings;
    }
    get name() {
        return this._name;
    }
    search(query) {
        return new RemoteQuery(query, this._client, this._name); //, this._embeddings_new)
    }
    add(data) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
    overwrite(data) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
    createIndex(indexParams) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
    countRows() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
    delete(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
}
exports.RemoteTable = RemoteTable;
