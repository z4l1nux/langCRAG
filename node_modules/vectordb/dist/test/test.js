"use strict";
// Copyright 2023 LanceDB Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const mocha_1 = require("mocha");
const temp_1 = require("temp");
const chai = require("chai");
const chaiAsPromised = require("chai-as-promised");
const lancedb = require("../index");
const index_1 = require("../index");
const expect = chai.expect;
const assert = chai.assert;
chai.use(chaiAsPromised);
(0, mocha_1.describe)('LanceDB client', function () {
    (0, mocha_1.describe)('when creating a connection to lancedb', function () {
        it('should have a valid url', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB();
                const con = yield lancedb.connect(uri);
                assert.equal(con.uri, uri);
            });
        });
        it('should accept an options object', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB();
                const con = yield lancedb.connect({ uri });
                assert.equal(con.uri, uri);
            });
        });
        it('should accept custom aws credentials', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB();
                const awsCredentials = {
                    accessKeyId: '',
                    secretKey: ''
                };
                const con = yield lancedb.connect({ uri, awsCredentials });
                assert.equal(con.uri, uri);
            });
        });
        it('should return the existing table names', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB();
                const con = yield lancedb.connect(uri);
                assert.deepEqual(yield con.tableNames(), ['vectors']);
            });
        });
    });
    (0, mocha_1.describe)('when querying an existing dataset', function () {
        it('should open a table', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB();
                const con = yield lancedb.connect(uri);
                const table = yield con.openTable('vectors');
                assert.equal(table.name, 'vectors');
            });
        });
        it('execute a query', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB();
                const con = yield lancedb.connect(uri);
                const table = yield con.openTable('vectors');
                const results = yield table.search([0.1, 0.3]).execute();
                assert.equal(results.length, 2);
                assert.equal(results[0].price, 10);
                const vector = results[0].vector;
                assert.approximately(vector[0], 0.0, 0.2);
                assert.approximately(vector[0], 0.1, 0.3);
            });
        });
        it('limits # of results', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB();
                const con = yield lancedb.connect(uri);
                const table = yield con.openTable('vectors');
                const results = yield table.search([0.1, 0.3]).limit(1).execute();
                assert.equal(results.length, 1);
                assert.equal(results[0].id, 1);
            });
        });
        it('uses a filter / where clause', function () {
            return __awaiter(this, void 0, void 0, function* () {
                // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
                const assertResults = (results) => {
                    assert.equal(results.length, 1);
                    assert.equal(results[0].id, 2);
                };
                const uri = yield createTestDB();
                const con = yield lancedb.connect(uri);
                const table = yield con.openTable('vectors');
                let results = yield table.search([0.1, 0.1]).filter('id == 2').execute();
                assertResults(results);
                results = yield table.search([0.1, 0.1]).where('id == 2').execute();
                assertResults(results);
            });
        });
        it('select only a subset of columns', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB();
                const con = yield lancedb.connect(uri);
                const table = yield con.openTable('vectors');
                const results = yield table.search([0.1, 0.1]).select(['is_active']).execute();
                assert.equal(results.length, 2);
                // vector and score are always returned
                assert.isDefined(results[0].vector);
                assert.isDefined(results[0].score);
                assert.isDefined(results[0].is_active);
                assert.isUndefined(results[0].id);
                assert.isUndefined(results[0].name);
                assert.isUndefined(results[0].price);
            });
        });
    });
    (0, mocha_1.describe)('when creating a new dataset', function () {
        it('creates a new table from javascript objects', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const dir = yield (0, temp_1.track)().mkdir('lancejs');
                const con = yield lancedb.connect(dir);
                const data = [
                    { id: 1, vector: [0.1, 0.2], price: 10 },
                    { id: 2, vector: [1.1, 1.2], price: 50 }
                ];
                const tableName = `vectors_${Math.floor(Math.random() * 100)}`;
                const table = yield con.createTable(tableName, data);
                assert.equal(table.name, tableName);
                assert.equal(yield table.countRows(), 2);
            });
        });
        it('fails to create a new table when the vector column is missing', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const dir = yield (0, temp_1.track)().mkdir('lancejs');
                const con = yield lancedb.connect(dir);
                const data = [
                    { id: 1, price: 10 }
                ];
                const create = con.createTable('missing_vector', data);
                yield expect(create).to.be.rejectedWith(Error, 'column \'vector\' is missing');
            });
        });
        it('use overwrite flag to overwrite existing table', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const dir = yield (0, temp_1.track)().mkdir('lancejs');
                const con = yield lancedb.connect(dir);
                const data = [
                    { id: 1, vector: [0.1, 0.2], price: 10 },
                    { id: 2, vector: [1.1, 1.2], price: 50 }
                ];
                const tableName = 'overwrite';
                yield con.createTable(tableName, data, { writeMode: index_1.WriteMode.Create });
                const newData = [
                    { id: 1, vector: [0.1, 0.2], price: 10 },
                    { id: 2, vector: [1.1, 1.2], price: 50 },
                    { id: 3, vector: [1.1, 1.2], price: 50 }
                ];
                yield expect(con.createTable(tableName, newData)).to.be.rejectedWith(Error, 'already exists');
                const table = yield con.createTable(tableName, newData, { writeMode: index_1.WriteMode.Overwrite });
                assert.equal(table.name, tableName);
                assert.equal(yield table.countRows(), 3);
            });
        });
        it('appends records to an existing table ', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const dir = yield (0, temp_1.track)().mkdir('lancejs');
                const con = yield lancedb.connect(dir);
                const data = [
                    { id: 1, vector: [0.1, 0.2], price: 10, name: 'a' },
                    { id: 2, vector: [1.1, 1.2], price: 50, name: 'b' }
                ];
                const table = yield con.createTable('vectors', data);
                assert.equal(yield table.countRows(), 2);
                const dataAdd = [
                    { id: 3, vector: [2.1, 2.2], price: 10, name: 'c' },
                    { id: 4, vector: [3.1, 3.2], price: 50, name: 'd' }
                ];
                yield table.add(dataAdd);
                assert.equal(yield table.countRows(), 4);
            });
        });
        it('overwrite all records in a table', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB();
                const con = yield lancedb.connect(uri);
                const table = yield con.openTable('vectors');
                assert.equal(yield table.countRows(), 2);
                const dataOver = [
                    { vector: [2.1, 2.2], price: 10, name: 'foo' },
                    { vector: [3.1, 3.2], price: 50, name: 'bar' }
                ];
                yield table.overwrite(dataOver);
                assert.equal(yield table.countRows(), 2);
            });
        });
        it('can delete records from a table', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB();
                const con = yield lancedb.connect(uri);
                const table = yield con.openTable('vectors');
                assert.equal(yield table.countRows(), 2);
                yield table.delete('price = 10');
                assert.equal(yield table.countRows(), 1);
            });
        });
    });
    (0, mocha_1.describe)('when creating a vector index', function () {
        it('overwrite all records in a table', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB(32, 300);
                const con = yield lancedb.connect(uri);
                const table = yield con.openTable('vectors');
                yield table.createIndex({ type: 'ivf_pq', column: 'vector', num_partitions: 2, max_iters: 2, num_sub_vectors: 2 });
            });
        }).timeout(10000); // Timeout is high partially because GH macos runner is pretty slow
        it('replace an existing index', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB(16, 300);
                const con = yield lancedb.connect(uri);
                const table = yield con.openTable('vectors');
                yield table.createIndex({ type: 'ivf_pq', column: 'vector', num_partitions: 2, max_iters: 2, num_sub_vectors: 2 });
                // Replace should fail if the index already exists
                yield expect(table.createIndex({
                    type: 'ivf_pq', column: 'vector', num_partitions: 2, max_iters: 2, num_sub_vectors: 2, replace: false
                })).to.be.rejectedWith('LanceError(Index)');
                // Default replace = true
                yield table.createIndex({ type: 'ivf_pq', column: 'vector', num_partitions: 2, max_iters: 2, num_sub_vectors: 2 });
            });
        }).timeout(50000);
        it('it should fail when the column is not a vector', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uri = yield createTestDB(32, 300);
                const con = yield lancedb.connect(uri);
                const table = yield con.openTable('vectors');
                const createIndex = table.createIndex({ type: 'ivf_pq', column: 'name', num_partitions: 2, max_iters: 2, num_sub_vectors: 2 });
                yield expect(createIndex).to.be.rejectedWith(/VectorIndex requires the column data type to be fixed size list of float32s/);
            });
        });
    });
    (0, mocha_1.describe)('when using a custom embedding function', function () {
        class TextEmbedding {
            constructor(targetColumn) {
                this._embedding_map = new Map([
                    ['foo', [2.1, 2.2]],
                    ['bar', [3.1, 3.2]]
                ]);
                this.sourceColumn = targetColumn;
            }
            embed(data) {
                return __awaiter(this, void 0, void 0, function* () {
                    return data.map(datum => { var _a; return (_a = this._embedding_map.get(datum)) !== null && _a !== void 0 ? _a : [0.0, 0.0]; });
                });
            }
        }
        it('should encode the original data into embeddings', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const dir = yield (0, temp_1.track)().mkdir('lancejs');
                const con = yield lancedb.connect(dir);
                const embeddings = new TextEmbedding('name');
                const data = [
                    { price: 10, name: 'foo' },
                    { price: 50, name: 'bar' }
                ];
                const table = yield con.createTable('vectors', data, embeddings, { writeMode: index_1.WriteMode.Create });
                const results = yield table.search('foo').execute();
                assert.equal(results.length, 2);
            });
        });
    });
});
(0, mocha_1.describe)('Query object', function () {
    it('sets custom parameters', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const query = new index_1.Query([0.1, 0.3])
                .limit(1)
                .metricType(index_1.MetricType.Cosine)
                .refineFactor(100)
                .select(['a', 'b'])
                .nprobes(20);
            assert.equal(query._limit, 1);
            assert.equal(query._metricType, index_1.MetricType.Cosine);
            assert.equal(query._refineFactor, 100);
            assert.equal(query._nprobes, 20);
            assert.deepEqual(query._select, ['a', 'b']);
        });
    });
});
function createTestDB(numDimensions = 2, numRows = 2) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = yield (0, temp_1.track)().mkdir('lancejs');
        const con = yield lancedb.connect(dir);
        const data = [];
        for (let i = 0; i < numRows; i++) {
            const vector = [];
            for (let j = 0; j < numDimensions; j++) {
                vector.push(i + (j * 0.1));
            }
            data.push({ id: i + 1, name: `name_${i}`, price: i + 10, is_active: (i % 2 === 0), vector });
        }
        yield con.createTable('vectors', data);
        return dir;
    });
}
(0, mocha_1.describe)('Drop table', function () {
    it('drop a table', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const dir = yield (0, temp_1.track)().mkdir('lancejs');
            const con = yield lancedb.connect(dir);
            const data = [
                { price: 10, name: 'foo', vector: [1, 2, 3] },
                { price: 50, name: 'bar', vector: [4, 5, 6] }
            ];
            yield con.createTable('t1', data);
            yield con.createTable('t2', data);
            assert.deepEqual(yield con.tableNames(), ['t1', 't2']);
            yield con.dropTable('t1');
            assert.deepEqual(yield con.tableNames(), ['t2']);
        });
    });
});
(0, mocha_1.describe)('WriteOptions', function () {
    context('#isWriteOptions', function () {
        it('should not match empty object', function () {
            assert.equal((0, index_1.isWriteOptions)({}), false);
        });
        it('should match write options', function () {
            assert.equal((0, index_1.isWriteOptions)({ writeMode: index_1.WriteMode.Create }), true);
        });
        it('should match undefined write mode', function () {
            assert.equal((0, index_1.isWriteOptions)({ writeMode: undefined }), true);
        });
        it('should match default write options', function () {
            assert.equal((0, index_1.isWriteOptions)(new index_1.DefaultWriteOptions()), true);
        });
    });
});
